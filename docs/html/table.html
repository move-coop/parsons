

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Parsons Table &mdash; Parsons 0.5 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Notifications" href="notifications.html" />
    <link rel="prev" title="Database Sync" href="dbsync.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Parsons
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Integrations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="action_kit.html">ActionKit</a></li>
<li class="toctree-l1"><a class="reference internal" href="action_network.html">Action Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="airtable.html">Airtable</a></li>
<li class="toctree-l1"><a class="reference internal" href="aws.html">Amazon Web Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="azure.html">Azure: Blob Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="bill_com.html">Bill.com</a></li>
<li class="toctree-l1"><a class="reference internal" href="bloomerang.html">Bloomerang</a></li>
<li class="toctree-l1"><a class="reference internal" href="box.html">Box</a></li>
<li class="toctree-l1"><a class="reference internal" href="braintree.html">Braintree</a></li>
<li class="toctree-l1"><a class="reference internal" href="civis.html">Civis</a></li>
<li class="toctree-l1"><a class="reference internal" href="copper.html">Copper</a></li>
<li class="toctree-l1"><a class="reference internal" href="crowdtangle.html">CrowdTangle</a></li>
<li class="toctree-l1"><a class="reference internal" href="databases.html">Databases</a></li>
<li class="toctree-l1"><a class="reference internal" href="facebook_ads.html">FacebookAds</a></li>
<li class="toctree-l1"><a class="reference internal" href="freshdesk.html">Freshdesk</a></li>
<li class="toctree-l1"><a class="reference internal" href="github.html">GitHub</a></li>
<li class="toctree-l1"><a class="reference internal" href="google.html">Google</a></li>
<li class="toctree-l1"><a class="reference internal" href="hustle.html">Hustle</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailchimp.html">Mailchimp</a></li>
<li class="toctree-l1"><a class="reference internal" href="mobilize_america.html">Mobilize America</a></li>
<li class="toctree-l1"><a class="reference internal" href="newmode.html">New/Mode</a></li>
<li class="toctree-l1"><a class="reference internal" href="ngpvan.html">NGPVAN</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdi.html">PDI</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2a.html">Phone2Action</a></li>
<li class="toctree-l1"><a class="reference internal" href="redash.html">Redash</a></li>
<li class="toctree-l1"><a class="reference internal" href="rockthevote.html">Rock the Vote</a></li>
<li class="toctree-l1"><a class="reference internal" href="salesforce.html">Salesforce</a></li>
<li class="toctree-l1"><a class="reference internal" href="sftp.html">SFTP</a></li>
<li class="toctree-l1"><a class="reference internal" href="targetsmart.html">TargetSmart</a></li>
<li class="toctree-l1"><a class="reference internal" href="turbovote.html">TurboVote</a></li>
<li class="toctree-l1"><a class="reference internal" href="twilio.html">Twilio</a></li>
<li class="toctree-l1"><a class="reference internal" href="zoom.html">Zoom</a></li>
</ul>
<p class="caption"><span class="caption-text">Enhancements</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="census_geocoder.html">US Census Geocoder</a></li>
</ul>
<p class="caption"><span class="caption-text">Framework</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="dbsync.html">Database Sync</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Parsons Table</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#from-parsons-table">From Parsons Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="#to-parsons-table">To Parsons Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parsons-table-attributes">Parsons Table Attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parsons-table-transformations">Parsons Table Transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parsons-table-indexing">Parsons Table Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#petl">PETL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lazy-loading">Lazy Loading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-pipelines">Basic Pipelines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#to-from-api">To &amp; From API</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transformation-api">Transformation API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="notifications.html">Notifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utilities</a></li>
</ul>
<p class="caption"><span class="caption-text">Contributor Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to Parsons</a></li>
<li class="toctree-l1"><a class="reference internal" href="build_a_connector.html">How to Build a Connector</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Parsons</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Parsons Table</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/table.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="parsons-table">
<span id="id1"></span><h1>Parsons Table<a class="headerlink" href="#parsons-table" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Most methods and functions in Parsons return a <code class="docutils literal notranslate"><span class="pre">Table</span></code>, which is a 2D list-like object similar to a Pandas Dataframe. You can call the following methods on the Table object to output it into a variety of formats or storage types. A full list of <code class="docutils literal notranslate"><span class="pre">Table</span></code> methods can be found in the API section.</p>
<div class="section" id="from-parsons-table">
<h3>From Parsons Table<a class="headerlink" href="#from-parsons-table" title="Permalink to this headline">¶</a></h3>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Destination Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.to_csv" title="parsons.etl.tofrom.ToFrom.to_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_csv()</span></code></a></td>
<td>CSV File</td>
<td>Write a table to a local csv file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.to_s3_csv" title="parsons.etl.tofrom.ToFrom.to_s3_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_s3_csv()</span></code></a></td>
<td>AWS s3 Bucket</td>
<td>Write a table to a csv stored in S3</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.to_sftp_csv" title="parsons.etl.tofrom.ToFrom.to_sftp_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_sftp_csv()</span></code></a></td>
<td>SFTP Server</td>
<td>Write a table to a csv stored on an SFTP server</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_csv" title="parsons.etl.tofrom.ToFrom.from_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_csv()</span></code></a></td>
<td>A Redshift Database</td>
<td>Write a table to a Redshift database</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_postgres" title="parsons.etl.tofrom.ToFrom.from_postgres"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_postgres()</span></code></a></td>
<td>A Postgres Database</td>
<td>Write a table to a Postgres database</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.to_civis" title="parsons.etl.tofrom.ToFrom.to_civis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_civis()</span></code></a></td>
<td>Civis Redshift Database</td>
<td>Write a table to Civis platform database</td>
</tr>
<tr class="row-even"><td><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_petl()</span></code></td>
<td>Petl table object</td>
<td>Convert a table a Petl table object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.to_json" title="parsons.etl.tofrom.ToFrom.to_json"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_json()</span></code></a></td>
<td>JSON file</td>
<td>Write a table to a local JSON file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.to_html" title="parsons.etl.tofrom.ToFrom.to_html"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_html()</span></code></a></td>
<td>HTML formatted table</td>
<td>Write a table to a local html file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.to_dataframe" title="parsons.etl.tofrom.ToFrom.to_dataframe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_dataframe()</span></code></a></td>
<td>Pandas Dataframe <a class="footnote-reference" href="#id3" id="id2">[1]</a></td>
<td>Return a Pandas dataframe</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Requires optional installation of Pandas package by running <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pandas</span></code>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="to-parsons-table">
<h3>To Parsons Table<a class="headerlink" href="#to-parsons-table" title="Permalink to this headline">¶</a></h3>
<p>Create Parsons Table object using the following methods.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Source Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_csv" title="parsons.etl.tofrom.ToFrom.from_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_csv()</span></code></a></td>
<td>File like object, local path, url, ftp.</td>
<td>Loads a csv object into a Table</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_json" title="parsons.etl.tofrom.ToFrom.from_json"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_json()</span></code></a></td>
<td>File like object, local path, url, ftp.</td>
<td>Loads a json object into a Table</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_columns" title="parsons.etl.tofrom.ToFrom.from_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_columns()</span></code></a></td>
<td>List object</td>
<td>Loads lists organized as columns in Table</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_redshift" title="parsons.etl.tofrom.ToFrom.from_redshift"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_redshift()</span></code></a></td>
<td>Redshift table</td>
<td>Loads a Redshift query into a Table</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_postgres" title="parsons.etl.tofrom.ToFrom.from_postgres"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_postgres()</span></code></a></td>
<td>Postgres table</td>
<td>Loads a Postgres query into a Table</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_dataframe" title="parsons.etl.tofrom.ToFrom.from_dataframe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_dataframe()</span></code></a></td>
<td>Pandas Dataframe <a class="footnote-reference" href="#id5" id="id4">[2]</a></td>
<td>Load a Parsons table from a Pandas Dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.tofrom.ToFrom.from_s3_csv" title="parsons.etl.tofrom.ToFrom.from_s3_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_s3_csv()</span></code></a></td>
<td>S3 CSV</td>
<td>Load a Parsons table from a csv file on S3</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>Requires optional installation of Pandas package by running <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pandas</span></code>.</td></tr>
</tbody>
</table>
<p>You can also use the Table constructor to create a Table from a python list or petl table:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># From a list of dicts</span>
<span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">([{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}])</span>

<span class="c1"># From a list of lists, the first list holding the field names</span>
<span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>

<span class="c1"># From a petl table</span>
<span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">petl_tbl</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="parsons-table-attributes">
<h3>Parsons Table Attributes<a class="headerlink" href="#parsons-table-attributes" title="Permalink to this headline">¶</a></h3>
<p>Tables have a number of convenience attributes.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">.num_rows</span></code></td>
<td>The number of rows in the table</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.columns</span></code></td>
<td>A list of column names in the table</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">.data</span></code></td>
<td>The actual data (rows) of the table, as a list of tuples (without field names)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.first</span></code></td>
<td>The first value in the table. Use for database queries where a single value is returned.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="parsons-table-transformations">
<h3>Parsons Table Transformations<a class="headerlink" href="#parsons-table-transformations" title="Permalink to this headline">¶</a></h3>
<p>Parsons tables have many methods that allow you to easily transform tables. Below is a selection
of commonly used methods. The full list can be found in the API section.</p>
<p><strong>Column Transformations</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.add_column" title="parsons.etl.etl.ETL.add_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_column()</span></code></a></td>
<td>Add a column</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.remove_column" title="parsons.etl.etl.ETL.remove_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_column()</span></code></a></td>
<td>Remove a column</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.rename_column" title="parsons.etl.etl.ETL.rename_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename_column()</span></code></a></td>
<td>Rename a column</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.move_column" title="parsons.etl.etl.ETL.move_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">move_column()</span></code></a></td>
<td>Move a column within a table</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.cut" title="parsons.etl.etl.ETL.cut"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cut()</span></code></a></td>
<td>Return a table with a subset of columns</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.fill_column" title="parsons.etl.etl.ETL.fill_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill_column()</span></code></a></td>
<td>Provide a fixed value to fill a column</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.fillna_column" title="parsons.etl.etl.ETL.fillna_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillna_column()</span></code></a></td>
<td>Provide a fixed value to fill all null values in a column</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.get_column_types" title="parsons.etl.etl.ETL.get_column_types"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_column_types()</span></code></a></td>
<td>Get the python type of values for a given column</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.convert_column" title="parsons.etl.etl.ETL.convert_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convert_column()</span></code></a></td>
<td>Transform the values of a column via arbitrary functions</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.coalesce_columns" title="parsons.etl.etl.ETL.coalesce_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coalesce_columns()</span></code></a></td>
<td>Coalesce values from one or more source columns</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.map_columns" title="parsons.etl.etl.ETL.map_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map_columns()</span></code></a></td>
<td>Standardizes column names based on multiple possible values</td>
</tr>
</tbody>
</table>
<p><strong>Row Transformations</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.select_rows" title="parsons.etl.etl.ETL.select_rows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_rows()</span></code></a></td>
<td>Return a table of a subset of rows based on filters</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.stack" title="parsons.etl.etl.ETL.stack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stack()</span></code></a></td>
<td>Stack a number of tables on top of one another</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.chunk" title="parsons.etl.etl.ETL.chunk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chunk()</span></code></a></td>
<td>Divide tables into smaller tables based on row count</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.remove_null_rows" title="parsons.etl.etl.ETL.remove_null_rows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_null_rows()</span></code></a></td>
<td>Removes rows with null values in specified columns</td>
</tr>
</tbody>
</table>
<p><strong>Extraction and Reshaping</strong></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.unpack_dict" title="parsons.etl.etl.ETL.unpack_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpack_dict()</span></code></a></td>
<td>Unpack dictionary values from one column to top level columns</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.unpack_list" title="parsons.etl.etl.ETL.unpack_list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpack_list()</span></code></a></td>
<td>Unpack list values from one column and add to top level columns</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#parsons.etl.etl.ETL.long_table" title="parsons.etl.etl.ETL.long_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">long_table()</span></code></a></td>
<td>Take a column with nested data and create a new long table</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#parsons.etl.etl.ETL.unpack_nested_columns_as_rows" title="parsons.etl.etl.ETL.unpack_nested_columns_as_rows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpack_nested_columns_as_rows()</span></code></a></td>
<td>Unpack list or dict values from one column into separate rows</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="parsons-table-indexing">
<h3>Parsons Table Indexing<a class="headerlink" href="#parsons-table-indexing" title="Permalink to this headline">¶</a></h3>
<p>To access rows and columns of data within a Parsons table, you can index on them. To access a column
pass in the column name as a string (e.g. <code class="docutils literal notranslate"><span class="pre">tbl['a']</span></code>) and to access a row, pass in the row index as
an integer (e.g. <code class="docutils literal notranslate"><span class="pre">tbl[1]</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">([{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}])</span>

<span class="c1"># Return a column as a list</span>
<span class="n">tbl</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="c1"># Return a row as a dict</span>
<span class="n">tbl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
</pre></div>
</div>
<p>A note on indexing and iterating over a table’s data:
If you need to iterate over the data, make sure to use the python iterator syntax, so any data transformations can be applied efficiently. An example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Some data transformations</span>
<span class="n">table</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s1">&#39;newcol&#39;</span><span class="p">,</span> <span class="s1">&#39;some value&#39;</span><span class="p">)</span>

<span class="c1"># Efficient way to grab all the data (applying the data transformations only once)</span>
<span class="n">rows_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you must index directly into a table’s data, you can do so, but note that data transformations will be applied <strong>each time</strong> you do so. So this code will be very inefficient on a large table…</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Inefficient way to grab all the data</span>
<span class="n">rows_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">num_rows</span><span class="p">):</span>
  <span class="c1"># Data transformations will be applied each time through this loop!</span>
  <span class="n">rows_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="petl">
<h3>PETL<a class="headerlink" href="#petl" title="Permalink to this headline">¶</a></h3>
<p>The Parsons <code class="docutils literal notranslate"><span class="pre">Table</span></code> relies heavily on the <a class="reference external" href="https://petl.readthedocs.io/en/stable/index.html">petl</a> Python package. You can always access the underlying petl table with <code class="docutils literal notranslate"><span class="pre">my_parsons_table.table</span></code>, which will allow you to perform any petl-supported ETL operations.</p>
</div>
<div class="section" id="lazy-loading">
<h3>Lazy Loading<a class="headerlink" href="#lazy-loading" title="Permalink to this headline">¶</a></h3>
<p>The Parsons <code class="docutils literal notranslate"><span class="pre">Table</span></code> makes use of “lazy” loading and “lazy” transformations. What this means is that it tries not to load and process your data until absolutely necessary.</p>
<p>An example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify where to load the data</span>
<span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="o">.</span><span class="n">from_csv</span><span class="p">(</span><span class="s1">&#39;name_data.csv&#39;</span><span class="p">)</span>

<span class="c1"># Specify data transformations</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s1">&#39;full_name&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;first_name&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;last_name&#39;</span><span class="p">])</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">remove_column</span><span class="p">([</span><span class="s1">&#39;first_name&#39;</span><span class="p">,</span> <span class="s1">&#39;last_name&#39;</span><span class="p">])</span>

<span class="c1"># Save the table elsewhere</span>
<span class="c1"># IMPORTANT - The CSV won&#39;t actually be loaded and transformed until this step,</span>
<span class="c1"># since this is the first time it&#39;s actually needed.</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">to_redshift</span><span class="p">(</span><span class="s1">&#39;main.name_table&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This “lazy” loading can be very convenient and performant. However, it can make issues hard to debug. Eg. if your data transformations are time-consuming, you won’t actually notice that performance hit until you try to use the data, potentially much later in your code.</p>
<p>So just be aware of this behavior.</p>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="basic-pipelines">
<h3>Basic Pipelines<a class="headerlink" href="#basic-pipelines" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># S3 to Civis</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">S3</span><span class="p">()</span>
<span class="n">csv</span> <span class="o">=</span> <span class="n">s3</span><span class="o">.</span><span class="n">get_file</span><span class="p">(</span><span class="s1">&#39;tmc-bucket&#39;</span><span class="p">,</span> <span class="s1">&#39;my_ids.csv&#39;</span><span class="p">)</span>
<span class="n">Table</span><span class="o">.</span><span class="n">from_csv</span><span class="p">(</span><span class="n">csv</span><span class="p">)</span><span class="o">.</span><span class="n">to_civis</span><span class="p">(</span><span class="s1">&#39;TMC&#39;</span><span class="p">,</span><span class="s1">&#39;ids.my_ids&#39;</span><span class="p">)</span>

<span class="c1">#VAN Activist Codes to a Dataframe</span>
<span class="n">van</span> <span class="o">=</span> <span class="n">VAN</span><span class="p">(</span><span class="n">db</span><span class="o">=</span><span class="s1">&#39;MyVoters&#39;</span><span class="p">)</span>
<span class="n">van</span><span class="o">.</span><span class="n">activist_codes</span><span class="p">()</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>

<span class="c1">#VAN Events to an s3 bucket</span>
<span class="n">van</span> <span class="o">=</span> <span class="n">VAN</span><span class="p">(</span><span class="n">db</span><span class="o">=</span><span class="s1">&#39;MyVoters&#39;</span><span class="p">)</span>
<span class="n">van</span><span class="o">.</span><span class="n">events</span><span class="p">()</span><span class="o">.</span><span class="n">to_s3_csv</span><span class="p">(</span><span class="s1">&#39;my-van-bucket&#39;</span><span class="p">,</span><span class="s1">&#39;myevents.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="to-from-api">
<h2>To &amp; From API<a class="headerlink" href="#to-from-api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="parsons.etl.tofrom.ToFrom">
<em class="property">class </em><code class="descclassname">parsons.etl.tofrom.</code><code class="descname">ToFrom</code><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_dataframe">
<code class="descname">to_dataframe</code><span class="sig-paren">(</span><em>index=None</em>, <em>exclude=None</em>, <em>columns=None</em>, <em>coerce_float=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_dataframe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs table as a Pandas Dataframe</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>index: str, list</dt>
<dd>Field of array to use as the index, alternately a specific set
of input labels to use</dd>
<dt>exclude: list</dt>
<dd>Columns or fields to exclude</dd>
<dt>columns: list</dt>
<dd>Column names to use. If the passed data do not have names
associated with them, this argument provides names for the
columns. Otherwise this argument indicates the order of the
columns in the result (any names not found in the data will
become all-NA columns)</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>dataframe</dt>
<dd>Pandas DataFrame object</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_html">
<code class="descname">to_html</code><span class="sig-paren">(</span><em>local_path=None</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>index_header=False</em>, <em>caption=None</em>, <em>tr_style=None</em>, <em>td_styles=None</em>, <em>truncate=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_html"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_html" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs table to html.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If a file already exists at the given location, it will be
overwritten.</p>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>local_path: str</dt>
<dd>The path to write the html locally. If not specified, a temporary file will be
created and returned, and that file will be removed automatically when the script
is done running.</dd>
<dt>encoding: str</dt>
<dd>The encoding type for <a class="reference external" href="https://docs.python.org/2/library/csv.html#csv.writer/">csv.writer()</a></dd>
<dt>errors: str</dt>
<dd>Raise an Error if encountered</dd>
<dt>index_header: boolean</dt>
<dd>Prepend index to column names; Defaults to False.</dd>
<dt>caption: str</dt>
<dd>A caption to include with the html table.</dd>
<dt>tr_style: str or callable</dt>
<dd>Style to be applied to the table row.</dd>
<dt>td_styles: str, dict or callable</dt>
<dd>Styles to be applied to the table cells.</dd>
<dt>truncate: int</dt>
<dd>Length of cell data.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>str</dt>
<dd>The path of the new file</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_csv">
<code class="descname">to_csv</code><span class="sig-paren">(</span><em>local_path=None</em>, <em>temp_file_compression=None</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>write_header=True</em>, <em>csv_name=None</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs table to a CSV. Additional key word arguments are passed to <code class="docutils literal notranslate"><span class="pre">csv.writer()</span></code>. So,
e.g., to override the delimiter from the default CSV dialect, provide the delimiter
keyword argument.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If a file already exists at the given location, it will be
overwritten.</p>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>local_path: str</dt>
<dd>The path to write the csv locally. If it ends in “.gz” or “.zip”, the file will be
compressed. If not specified, a temporary file will be created and returned,
and that file will be removed automatically when the script is done running.</dd>
<dt>temp_file_compression: str</dt>
<dd>If a temp file is requested (ie. no <code class="docutils literal notranslate"><span class="pre">local_path</span></code> is specified), the compression
type for that file. Currently “None”, “gzip” or “zip” are supported.
If a <code class="docutils literal notranslate"><span class="pre">local_path</span></code> is specified, this argument is ignored.</dd>
<dt>encoding: str</dt>
<dd>The CSV encoding type for <a class="reference external" href="https://docs.python.org/2/library/csv.html#csv.writer/">csv.writer()</a></dd>
<dt>errors: str</dt>
<dd>Raise an Error if encountered</dd>
<dt>write_header: boolean</dt>
<dd>Include header in output</dd>
<dt>csv_name: str</dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">zip</span></code> compression (either specified or inferred), the name of csv file
within the archive.</dd>
<dt>**csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_writer</span></code> optional arguments</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>str</dt>
<dd>The path of the new file</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.append_csv">
<code class="descname">append_csv</code><span class="sig-paren">(</span><em>local_path</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.append_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.append_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends table to an existing CSV.</p>
<p>Additional additional key word arguments
are passed to <code class="docutils literal notranslate"><span class="pre">csv.writer()</span></code>. So, e.g., to override the delimiter
from the default CSV dialect, provide the delimiter keyword argument.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>local_path: str</dt>
<dd>The local path of an existing CSV file. If it ends in “.gz”, the file will
be compressed.</dd>
<dt>encoding: str</dt>
<dd>The CSV encoding type for <a class="reference external" href="https://docs.python.org/2/library/csv.html#csv.writer/">csv.writer()</a></dd>
<dt>errors: str</dt>
<dd>Raise an Error if encountered</dd>
<dt>**csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_writer</span></code> optional arguments</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>str</dt>
<dd>The path of the file</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_zip_csv">
<code class="descname">to_zip_csv</code><span class="sig-paren">(</span><em>archive_path=None</em>, <em>csv_name=None</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>write_header=True</em>, <em>if_exists='replace'</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_zip_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_zip_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs table to a CSV in a zip archive. Additional key word arguments are passed to
<code class="docutils literal notranslate"><span class="pre">csv.writer()</span></code>. So, e.g., to override the delimiter from the default CSV dialect,
provide the delimiter keyword argument. Use thismethod if you would like to write
multiple csv files to the same archive.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If a file already exists in the archive, it will be overwritten.</p>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>archive_path: str</dt>
<dd>The path to zip achive. If not specified, a temporary file will be created and
returned, and that file will be removed automatically when the script is done
running.</dd>
<dt>csv_name: str</dt>
<dd>The name of the csv file to be stored in the archive. If <code class="docutils literal notranslate"><span class="pre">None</span></code> will use
the archive name.</dd>
<dt>encoding: str</dt>
<dd>The CSV encoding type for <a class="reference external" href="https://docs.python.org/2/library/csv.html#csv.writer/">csv.writer()</a></dd>
<dt>errors: str</dt>
<dd>Raise an Error if encountered</dd>
<dt>write_header: boolean</dt>
<dd>Include header in output</dd>
<dt>if_exists: str</dt>
<dd>If archive already exists, one of ‘replace’ or ‘append’</dd>
<dt>**csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_writer</span></code> optional arguments</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>str</dt>
<dd>The path of the archive</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><em>local_path=None</em>, <em>temp_file_compression=None</em>, <em>line_delimited=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs table to a JSON file</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If a file already exists at the given location, it will be
overwritten.</p>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>local_path: str</dt>
<dd>The path to write the JSON locally. If it ends in “.gz”, it will be
compressed first. If not specified, a temporary file will be created and returned,
and that file will be removed automatically when the script is done running.</dd>
<dt>temp_file_compression: str</dt>
<dd>If a temp file is requested (ie. no <code class="docutils literal notranslate"><span class="pre">local_path</span></code> is specified), the compression
type for that file. Currently “None” and “gzip” are supported.
If a <code class="docutils literal notranslate"><span class="pre">local_path</span></code> is specified, this argument is ignored.</dd>
<dt>line_delimited: bool</dt>
<dd>Whether the file will be line-delimited JSON (with a row on each line), or a proper
JSON file.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>str</dt>
<dd>The path of the new file</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_dicts">
<code class="descname">to_dicts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_dicts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_dicts" title="Permalink to this definition">¶</a></dt>
<dd><p>Output table as a list of dicts.</p>
<dl class="docutils">
<dt><cite>Returns:</cite></dt>
<dd>list</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_sftp_csv">
<code class="descname">to_sftp_csv</code><span class="sig-paren">(</span><em>remote_path</em>, <em>host</em>, <em>username</em>, <em>password</em>, <em>port=22</em>, <em>encoding=None</em>, <em>compression=None</em>, <em>errors='strict'</em>, <em>write_header=True</em>, <em>rsa_private_key_file=None</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_sftp_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_sftp_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the table to a CSV file on a remote SFTP server</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>remote_path: str</dt>
<dd>The remote path of the file. If it ends in ‘.gz’, the file will be compressed.</dd>
<dt>host: str</dt>
<dd>The remote host</dd>
<dt>username: str</dt>
<dd>The username to access the SFTP server</dd>
<dt>password: str</dt>
<dd>The password to access the SFTP server</dd>
<dt>port: int</dt>
<dd>The port number of the SFTP server</dd>
<dt>encoding: str</dt>
<dd>The CSV encoding type for <a class="reference external" href="https://docs.python.org/2/library/csv.html#csv.writer/">csv.writer()</a></dd>
<dt>errors: str</dt>
<dd>Raise an Error if encountered</dd>
<dt>write_header: boolean</dt>
<dd>Include header in output</dd>
<dt>rsa_private_key_file str</dt>
<dd>Absolute path to a private RSA key used
to authenticate stfp connection</dd>
<dt>**csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_writer</span></code> optional arguments</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_s3_csv">
<code class="descname">to_s3_csv</code><span class="sig-paren">(</span><em>bucket</em>, <em>key</em>, <em>aws_access_key_id=None</em>, <em>aws_secret_access_key=None</em>, <em>compression=None</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>write_header=True</em>, <em>acl='bucket-owner-full-control'</em>, <em>public_url=False</em>, <em>public_url_expires=3600</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_s3_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_s3_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the table to an s3 object as a CSV</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>bucket: str</dt>
<dd>The s3 bucket to upload to</dd>
<dt>key: str</dt>
<dd>The s3 key to name the file. If it ends in ‘.gz’ or ‘.zip’, the file will be
compressed.</dd>
<dt>aws_access_key_id: str</dt>
<dd>Required if not included as environmental variable</dd>
<dt>aws_secret_access_key: str</dt>
<dd>Required if not included as environmental variable</dd>
<dt>compression: str</dt>
<dd>The compression type for the s3 object. Currently “None”, “zip” and “gzip” are
supported. If specified, will override the key suffix.</dd>
<dt>encoding: str</dt>
<dd>The CSV encoding type for <a class="reference external" href="https://docs.python.org/2/library/csv.html#csv.writer/">csv.writer()</a></dd>
<dt>errors: str</dt>
<dd>Raise an Error if encountered</dd>
<dt>write_header: boolean</dt>
<dd>Include header in output</dd>
<dt>public_url: boolean</dt>
<dd>Create a public link to the file</dd>
<dt>public_url_expire: 3600</dt>
<dd>The time, in seconds, until the url expires if <code class="docutils literal notranslate"><span class="pre">public_url</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</dd>
<dt>acl: str</dt>
<dd>The S3 permissions on the file</dd>
<dt>**csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_writer</span></code> optional arguments</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd>Public url if specified. If not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_redshift">
<code class="descname">to_redshift</code><span class="sig-paren">(</span><em>table_name</em>, <em>username=None</em>, <em>password=None</em>, <em>host=None</em>, <em>db=None</em>, <em>port=None</em>, <em>**copy_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_redshift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_redshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a table to a Redshift database. Note, this requires you to pass
AWS S3 credentials or store them as environmental variables.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>table_name: str</dt>
<dd>The table name and schema (<code class="docutils literal notranslate"><span class="pre">my_schema.my_table</span></code>) to point the file.</dd>
<dt>username: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_USERNAME</span></code> not populated</dd>
<dt>password: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_PASSWORD</span></code> not populated</dd>
<dt>host: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_HOST</span></code> not populated</dd>
<dt>db: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_DB</span></code> not populated</dd>
<dt>port: int</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_PORT</span></code> not populated. Port 5439 is typical.</dd>
<dt>**copy_args: kwargs</dt>
<dd>See <code class="xref py py-func docutils literal notranslate"><span class="pre">copy`()</span></code> for options.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">None</span></code></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_postgres">
<code class="descname">to_postgres</code><span class="sig-paren">(</span><em>table_name</em>, <em>username=None</em>, <em>password=None</em>, <em>host=None</em>, <em>db=None</em>, <em>port=None</em>, <em>**copy_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_postgres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_postgres" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a table to a Postgres database.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>table_name: str</dt>
<dd>The table name and schema (<code class="docutils literal notranslate"><span class="pre">my_schema.my_table</span></code>) to point the file.</dd>
<dt>username: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGUSER</span></code> not populated</dd>
<dt>password: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGPASSWORD</span></code> not populated</dd>
<dt>host: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGHOST</span></code> not populated</dd>
<dt>db: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGDATABASE</span></code> not populated</dd>
<dt>port: int</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGPORT</span></code> not populated.</dd>
<dt>**copy_args: kwargs</dt>
<dd>See <code class="xref py py-func docutils literal notranslate"><span class="pre">copy`()</span></code> for options.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">None</span></code></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.tofrom.ToFrom.to_civis">
<code class="descname">to_civis</code><span class="sig-paren">(</span><em>table</em>, <em>api_key=None</em>, <em>db=None</em>, <em>max_errors=None</em>, <em>existing_table_rows='fail'</em>, <em>diststyle=None</em>, <em>distkey=None</em>, <em>sortkey1=None</em>, <em>sortkey2=None</em>, <em>wait=True</em>, <em>**civisargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.to_civis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.to_civis" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the table to a Civis Redshift cluster. Additional key word
arguments can passed to <a class="reference external" href="https://civis-python.readthedocs.io/en/v1.9.0/generated/civis.io.dataframe_to_civis.html#civis.io.dataframe_to_civis">civis.io.dataframe_to_civis()</a> # noqa: E501</p>
<dl class="docutils">
<dt><cite>Args</cite></dt>
<dd><dl class="first last docutils">
<dt>table: str</dt>
<dd>The schema and table you want to upload to. E.g.,
‘scratch.table’. Schemas or tablenames with periods must be
double quoted, e.g. ‘scratch.”my.table”’.</dd>
<dt>api_key: str</dt>
<dd>Your Civis API key. If not given, the CIVIS_API_KEY environment
variable will be used.</dd>
<dt>db: str or int</dt>
<dd>The Civis Database. Can be database name or ID</dd>
<dt>max_errors: int</dt>
<dd>The maximum number of rows with errors to remove from
the import before failing.</dd>
<dt>diststyle: str</dt>
<dd>The distribution style for the table. One of <cite>‘even’</cite>, <cite>‘all’</cite>
or <cite>‘key’</cite>.</dd>
<dt>existing_table_rows: str</dt>
<dd>The behaviour if a table with the requested name already
exists. One of <cite>‘fail’</cite>, <cite>‘truncate’</cite>, <cite>‘append’</cite> or <cite>‘drop’</cite>.
Defaults to <cite>‘fail’</cite>.</dd>
<dt>distkey: str</dt>
<dd>The column to use as the distkey for the table.</dd>
<dt>sortkey1: str</dt>
<dd>The column to use as the sortkey for the table.</dd>
<dt>sortkey2: str</dt>
<dd>The second column in a compound sortkey for the table.</dd>
<dt>wait: boolean</dt>
<dd>Wait for write job to complete before exiting method.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_csv">
<em class="property">classmethod </em><code class="descname">from_csv</code><span class="sig-paren">(</span><em>local_path</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal notranslate"><span class="pre">parsons</span> <span class="pre">table</span></code> object from a CSV file</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>local_path: obj</dt>
<dd>A csv formatted local path, url or ftp. If this is a
file path that ends in “.gz”, the file will be decompressed first.</dd>
<dt>**csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_reader</span></code> optional arguments</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>Parsons Table</dt>
<dd>See <a class="reference internal" href="#parsons-table"><span class="std std-ref">Parsons Table</span></a> for output options.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_csv_string">
<em class="property">classmethod </em><code class="descname">from_csv_string</code><span class="sig-paren">(</span><em>str</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_csv_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_csv_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal notranslate"><span class="pre">parsons</span> <span class="pre">table</span></code> object from a string representing a CSV.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>str: str</dt>
<dd>The string object to convert to a table</dd>
<dt><a href="#id12"><span class="problematic" id="id13">**</span></a>csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_reader</span></code> optional arguments</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>Parsons Table</dt>
<dd>See <a class="reference internal" href="#parsons-table"><span class="std std-ref">Parsons Table</span></a> for output options.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_columns">
<em class="property">classmethod </em><code class="descname">from_columns</code><span class="sig-paren">(</span><em>cols</em>, <em>header=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal notranslate"><span class="pre">parsons</span> <span class="pre">table</span></code> from a list of lists organized as columns</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>cols: list</dt>
<dd>A list of lists organized as columns</dd>
<dt>header: list</dt>
<dd>List of column names. If not specified, will use dummy column names</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>Parsons Table</dt>
<dd>See <a class="reference internal" href="#parsons-table"><span class="std std-ref">Parsons Table</span></a> for output options.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_json">
<em class="property">classmethod </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>local_path</em>, <em>header=None</em>, <em>line_delimited=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal notranslate"><span class="pre">parsons</span> <span class="pre">table</span></code> from a json file</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>local_path: list</dt>
<dd>A JSON formatted local path, url or ftp. If this is a
file path that ends in “.gz”, the file will be decompressed first.</dd>
<dt>header: list</dt>
<dd>List of columns to use for the destination table. If omitted, columns will
be inferred from the initial data in the file.</dd>
<dt>line_delimited: bool</dt>
<dd>Whether the file is line-delimited JSON (with a row on each line), or a proper
JSON file.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>Parsons Table</dt>
<dd>See <a class="reference internal" href="#parsons-table"><span class="std std-ref">Parsons Table</span></a> for output options.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_redshift">
<em class="property">classmethod </em><code class="descname">from_redshift</code><span class="sig-paren">(</span><em>sql</em>, <em>username=None</em>, <em>password=None</em>, <em>host=None</em>, <em>db=None</em>, <em>port=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_redshift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_redshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal notranslate"><span class="pre">parsons</span> <span class="pre">table</span></code> from a Redshift query.</p>
<p>To pull an entire Redshift table, use a query like <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">tablename</span></code>.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>sql: str</dt>
<dd>A valid SQL statement</dd>
<dt>username: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_USERNAME</span></code> not populated</dd>
<dt>password: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_PASSWORD</span></code> not populated</dd>
<dt>host: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_HOST</span></code> not populated</dd>
<dt>db: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_DB</span></code> not populated</dd>
<dt>port: int</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">REDSHIFT_PORT</span></code> not populated. Port 5439 is typical.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>Parsons Table</dt>
<dd>See <a class="reference internal" href="#parsons-table"><span class="std std-ref">Parsons Table</span></a> for output options.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_postgres">
<em class="property">classmethod </em><code class="descname">from_postgres</code><span class="sig-paren">(</span><em>sql</em>, <em>username=None</em>, <em>password=None</em>, <em>host=None</em>, <em>db=None</em>, <em>port=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_postgres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_postgres" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>sql: str</dt>
<dd>A valid SQL statement</dd>
<dt>username: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGUSER</span></code> not populated</dd>
<dt>password: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGPASSWORD</span></code> not populated</dd>
<dt>host: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGHOST</span></code> not populated</dd>
<dt>db: str</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGDATABASE</span></code> not populated</dd>
<dt>port: int</dt>
<dd>Required if env variable <code class="docutils literal notranslate"><span class="pre">PGPORT</span></code> not populated.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_s3_csv">
<em class="property">classmethod </em><code class="descname">from_s3_csv</code><span class="sig-paren">(</span><em>bucket</em>, <em>key</em>, <em>from_manifest=False</em>, <em>aws_access_key_id=None</em>, <em>aws_secret_access_key=None</em>, <em>**csvargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_s3_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_s3_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal notranslate"><span class="pre">parsons</span> <span class="pre">table</span></code> from a key in an S3 bucket.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>bucket: str</dt>
<dd>The S3 bucket.</dd>
<dt>key: str</dt>
<dd>The S3 key</dd>
<dt>from_manifest: bool</dt>
<dd>If True, treats <cite>key</cite> as a manifest file and loads all urls into a <cite>parsons.Table</cite>.
Defaults to False.</dd>
<dt>aws_access_key_id: str</dt>
<dd>Required if not included as environmental variable.</dd>
<dt>aws_secret_access_key: str</dt>
<dd>Required if not included as environmental variable.</dd>
<dt>**csvargs: kwargs</dt>
<dd><code class="docutils literal notranslate"><span class="pre">csv_reader</span></code> optional arguments</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>parsons.Table</cite> object</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="parsons.etl.tofrom.ToFrom.from_dataframe">
<em class="property">classmethod </em><code class="descname">from_dataframe</code><span class="sig-paren">(</span><em>dataframe</em>, <em>include_index=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/tofrom.html#ToFrom.from_dataframe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.tofrom.ToFrom.from_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal notranslate"><span class="pre">parsons</span> <span class="pre">table</span></code> from a Pandas dataframe.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>dataframe: dataframe</dt>
<dd>A valid Pandas dataframe objectt</dd>
<dt>include_index: boolean</dt>
<dd>Include index column</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="transformation-api">
<h2>Transformation API<a class="headerlink" href="#transformation-api" title="Permalink to this headline">¶</a></h2>
<p>The following methods allow you to manipulate the Parsons table data.</p>
<dl class="class">
<dt id="parsons.etl.etl.ETL">
<em class="property">class </em><code class="descclassname">parsons.etl.etl.</code><code class="descname">ETL</code><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parsons.etl.etl.ETL.add_column">
<code class="descname">add_column</code><span class="sig-paren">(</span><em>column</em>, <em>value=None</em>, <em>index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.add_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.add_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column to your table</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str</dt>
<dd>Name of column to add</dd>
<dt>value:</dt>
<dd>A fixed or calculated value</dd>
<dt>index: int</dt>
<dd>The position of the new column in the table</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.remove_column">
<code class="descname">remove_column</code><span class="sig-paren">(</span><em>*columns</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.remove_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.remove_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a column from your table</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>*columns: str</dt>
<dd>Column names</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.rename_column">
<code class="descname">rename_column</code><span class="sig-paren">(</span><em>column_name</em>, <em>new_column_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.rename_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.rename_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename a column</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column_name: str</dt>
<dd>The current column name</dd>
<dt>new_column_name: str</dt>
<dd>The new column name</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.fill_column">
<code class="descname">fill_column</code><span class="sig-paren">(</span><em>column_name</em>, <em>fill_value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.fill_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.fill_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a column in a table</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column_name: str</dt>
<dd>The column to fill</dd>
<dt>fill_value:</dt>
<dd>A fixed or calculated value</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.fillna_column">
<code class="descname">fillna_column</code><span class="sig-paren">(</span><em>column_name</em>, <em>fill_value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.fillna_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.fillna_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill None values in a column in a table</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column_name: str</dt>
<dd>The column to fill</dd>
<dt>fill_value:</dt>
<dd>Fixed value only</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.move_column">
<code class="descname">move_column</code><span class="sig-paren">(</span><em>column</em>, <em>index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.move_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.move_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a column</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str</dt>
<dd>The column name to move</dd>
<dt>index:</dt>
<dd>The new index for the column</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates existing object.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.convert_column">
<code class="descname">convert_column</code><span class="sig-paren">(</span><em>*column</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.convert_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.convert_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform values under one or more fields via arbitrary functions, method
invocations or dictionary translations. This leverages the petl <code class="docutils literal notranslate"><span class="pre">convert()</span></code>
method. Example usage can be found <a class="reference external" href="https://petl.readthedocs.io/en/v0.24/transform.html#petl.convert">here</a>.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>*column: str</dt>
<dd>A single column or multiple columns passed as a list</dd>
<dt>**kwargs: str, method or variable</dt>
<dd>The update function, method, or variable to process the update</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.get_column_max_width">
<code class="descname">get_column_max_width</code><span class="sig-paren">(</span><em>column</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.get_column_max_width"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.get_column_max_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum width of the column.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str</dt>
<dd>The column name.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd>int</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.convert_columns_to_str">
<code class="descname">convert_columns_to_str</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.convert_columns_to_str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.convert_columns_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to convert all non-string or mixed columns in a
Parsons table to string (e.g. for comparison)</p>
<dl class="docutils">
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.coalesce_columns">
<code class="descname">coalesce_columns</code><span class="sig-paren">(</span><em>dest_column</em>, <em>source_columns</em>, <em>remove_source_columns=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.coalesce_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.coalesce_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Coalesces values from one or more source columns into a destination column, by selecting
the first non-empty value. If the destination column doesn’t exist, it will be added.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>dest_column: str</dt>
<dd>Name of destination column</dd>
<dt>source_columns: list</dt>
<dd>List of source column names</dd>
<dt>remove_source_columns: bool</dt>
<dd>Whether to remove the source columns after the coalesce. If the destination
column is also one of the source columns, it will not be removed.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.map_columns">
<code class="descname">map_columns</code><span class="sig-paren">(</span><em>column_map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.map_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.map_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardizes column names based on multiple possible values. This method
is helpful when your input table might have multiple and unknown column
names.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column_map: dict</dt>
<dd>A dictionary of columns and possible values that map to it</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="p">[{</span><span class="n">fn</span><span class="p">:</span> <span class="s1">&#39;Jane&#39;</span><span class="p">},</span>
       <span class="p">{</span><span class="n">lastname</span><span class="p">:</span> <span class="s1">&#39;Doe&#39;</span><span class="p">},</span>
       <span class="p">{</span><span class="n">dob</span><span class="p">:</span> <span class="s1">&#39;1980-01-01&#39;</span><span class="p">}]</span>
<span class="n">column_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">first_name</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;firstname&#39;</span><span class="p">],</span>
              <span class="n">last_name</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ln&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="s1">&#39;lastname&#39;</span><span class="p">],</span>
              <span class="n">date_of_birth</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;dob&#39;</span><span class="p">,</span> <span class="s1">&#39;birthday&#39;</span><span class="p">]}</span>
<span class="n">tbl</span><span class="o">.</span><span class="n">map_columns</span><span class="p">(</span><span class="n">column_map</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="p">{{</span><span class="n">first_name</span><span class="p">:</span> <span class="s1">&#39;Jane&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="p">:</span> <span class="s1">&#39;Doe&#39;</span><span class="p">,</span> <span class="s1">&#39;date_of_birth&#39;</span><span class="p">:</span> <span class="s1">&#39;1908-01-01&#39;</span><span class="p">}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.map_and_coalesce_columns">
<code class="descname">map_and_coalesce_columns</code><span class="sig-paren">(</span><em>column_map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.map_and_coalesce_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.map_and_coalesce_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Coalesces columns based on multiple possible values. The columns in the map
do not need to be in your table, so you can create a map with all possibilities.
The coalesce will occur in the order that the columns are listed, unless the
destination column name already exists in the table, in which case that
value will be preferenced. This method is helpful when your input table might
have multiple and unknown column names.
<cite>Args:</cite></p>
<blockquote>
<div><dl class="docutils">
<dt>column_map: dict</dt>
<dd>A dictionary of columns and possible values that map to it</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="p">[{</span><span class="n">first</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
       <span class="p">{</span><span class="n">fn</span><span class="p">:</span> <span class="s1">&#39;Jane&#39;</span><span class="p">},</span>
       <span class="p">{</span><span class="n">lastname</span><span class="p">:</span> <span class="s1">&#39;Doe&#39;</span><span class="p">},</span>
       <span class="p">{</span><span class="n">dob</span><span class="p">:</span> <span class="s1">&#39;1980-01-01&#39;</span><span class="p">}]</span>

<span class="n">column_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">first_name</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;firstname&#39;</span><span class="p">],</span>
              <span class="n">last_name</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ln&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="s1">&#39;lastname&#39;</span><span class="p">],</span>
              <span class="n">date_of_birth</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;dob&#39;</span><span class="p">,</span> <span class="s1">&#39;birthday&#39;</span><span class="p">]}</span>

<span class="n">tbl</span><span class="o">.</span><span class="n">map_and_coalesce_columns</span><span class="p">(</span><span class="n">column_map</span><span class="p">)</span>

<span class="nb">print</span> <span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="p">{{</span><span class="n">first_name</span><span class="p">:</span> <span class="s1">&#39;Jane&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="p">:</span> <span class="s1">&#39;Doe&#39;</span><span class="p">,</span> <span class="s1">&#39;date_of_birth&#39;</span><span class="p">:</span> <span class="s1">&#39;1908-01-01&#39;</span><span class="p">}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.get_column_types">
<code class="descname">get_column_types</code><span class="sig-paren">(</span><em>column</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.get_column_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.get_column_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all of the Python types for values in a given column</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str</dt>
<dd>Name of the column to analyze</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>list</dt>
<dd>A list of Python types</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.get_columns_type_stats">
<code class="descname">get_columns_type_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.get_columns_type_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.get_columns_type_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return descriptive stats for all columns</p>
<dl class="docutils">
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>list</dt>
<dd>A list of dicts</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>list</dt>
<dd>A list of dicts, each containing a column ‘name’ and a ‘type’ list</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.convert_table">
<code class="descname">convert_table</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.convert_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.convert_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform all cells in a table via arbitrary functions, method invocations or dictionary
translations. This method is useful for cleaning fields and data hygiene functions such
as regex. This method leverages the petl <code class="docutils literal notranslate"><span class="pre">convert()</span></code> method. Example usage can be
found <cite>here</cite> &lt;<a class="reference external" href="https://petl.readthedocs.io/en/v0.24/transform.html#petl.convert">https://petl.readthedocs.io/en/v0.24/transform.html#petl.convert</a>&gt;`_.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>*args: str, method or variable</dt>
<dd>The update function, method, or variable to process the update. Can also</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.unpack_dict">
<code class="descname">unpack_dict</code><span class="sig-paren">(</span><em>column</em>, <em>keys=None</em>, <em>include_original=False</em>, <em>sample_size=1000</em>, <em>missing=None</em>, <em>prepend=True</em>, <em>prepend_value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.unpack_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.unpack_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack dictionary values from one column into separate columns</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str</dt>
<dd>The column name to unpack</dd>
<dt>keys: list</dt>
<dd>The dict keys in the column to unpack. If <code class="docutils literal notranslate"><span class="pre">None</span></code> will unpack
all.</dd>
<dt>include_original: boolean</dt>
<dd>Retain original column after unpacking</dd>
<dt>sample_size: int</dt>
<dd>Number of rows to sample before determining columns</dd>
<dt>missing: str</dt>
<dd>If a value is missing, the value to fill it with</dd>
<dt>prepend:</dt>
<dd>Prepend the column name of the unpacked values. Useful for
avoiding duplicate column names</dd>
<dt>prepend_value:</dt>
<dd>Value to prepend new columns if <code class="docutils literal notranslate"><span class="pre">prepend=True</span></code>. If None, will
set to column name.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.unpack_list">
<code class="descname">unpack_list</code><span class="sig-paren">(</span><em>column</em>, <em>include_original=False</em>, <em>missing=None</em>, <em>replace=False</em>, <em>max_columns=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.unpack_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.unpack_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack list values from one column into separate columns. Numbers the
columns.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Begin with a list in column</span>
<span class="n">json</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span>
         <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Jane Green&#39;</span><span class="p">,</span>
         <span class="s1">&#39;phones&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;512-699-3334&#39;</span><span class="p">,</span> <span class="s1">&#39;512-222-5478&#39;</span><span class="p">]</span>
        <span class="p">}</span>
       <span class="p">]</span>

<span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">json</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Jane Green&#39;</span><span class="p">,</span> <span class="s1">&#39;phones&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;512-699-3334&#39;</span><span class="p">,</span> <span class="s1">&#39;512-222-5478&#39;</span><span class="p">]}</span>

<span class="n">tbl</span><span class="o">.</span><span class="n">unpack_list</span><span class="p">(</span><span class="s1">&#39;phones&#39;</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Jane Green&#39;</span><span class="p">,</span> <span class="s1">&#39;phones_0&#39;</span><span class="p">:</span> <span class="s1">&#39;512-699-3334&#39;</span><span class="p">,</span> <span class="s1">&#39;phones_1&#39;</span><span class="p">:</span> <span class="s1">&#39;512-222-5478&#39;</span><span class="p">}</span> <span class="c1"># noqa: E501</span>
</pre></div>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str</dt>
<dd>The column name to unpack</dd>
<dt>include_original: boolean</dt>
<dd>Retain original column after unpacking</dd>
<dt>sample_size: int</dt>
<dd>Number of rows to sample before determining columns</dd>
<dt>missing: str</dt>
<dd>If a value is missing, the value to fill it with</dd>
<dt>replace: boolean</dt>
<dd>Return new table or replace existing</dd>
<dt>max_columns: int</dt>
<dd>The maximum number of columns to unpack</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.unpack_nested_columns_as_rows">
<code class="descname">unpack_nested_columns_as_rows</code><span class="sig-paren">(</span><em>column</em>, <em>key='id'</em>, <em>expand_original=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.unpack_nested_columns_as_rows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.unpack_nested_columns_as_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack list or dict values from one column into separate rows.
Not recommended for JSON columns (i.e. lists of dicts), but can handle columns
with any mix of types. Makes use of PETL’s <cite>melt()</cite> method.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str</dt>
<dd>The column name to unpack</dd>
<dt>key: str</dt>
<dd>The column to use as a key when unpacking. Defaults to <cite>id</cite></dd>
<dt>expand_original: boolean or int</dt>
<dd>If <cite>True</cite>: Add resulting unpacked rows (with all other columns) to original
If <cite>int</cite>: Add to original unless the max added per key is above the given number
If <cite>False</cite> (default): Return unpacked rows (with <cite>key</cite> column only) as standalone
Removes packed list and dict rows from original either way.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd>If <cite>expand_original</cite>, original table with packed rows replaced by unpacked rows
Otherwise, standalone table with key column and unpacked values only</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.long_table">
<code class="descname">long_table</code><span class="sig-paren">(</span><em>key</em>, <em>column</em>, <em>key_rename=None</em>, <em>retain_original=False</em>, <em>prepend=True</em>, <em>prepend_value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.long_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.long_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new long parsons table from a column, including the foreign
key.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Begin with nested dicts in a column</span>
<span class="n">json</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span>
         <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Jane Green&#39;</span><span class="p">,</span>
         <span class="s1">&#39;emails&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;home&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@gmail.com&#39;</span><span class="p">},</span>
                    <span class="p">{</span><span class="s1">&#39;work&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@mywork.com&#39;</span><span class="p">}</span>
                   <span class="p">]</span>
        <span class="p">}</span>
       <span class="p">]</span>
<span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">json</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Jane Green&#39;</span><span class="p">,</span> <span class="s1">&#39;emails&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;home&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@gmail.com&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;work&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@mywork.com&#39;</span><span class="p">}]}</span> <span class="c1"># noqa: E501</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Jane Green&#39;</span><span class="p">,</span> <span class="s1">&#39;emails&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;home&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@gmail.com&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;work&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@mywork.com&#39;</span><span class="p">}]}</span> <span class="c1"># noqa: E501</span>

<span class="c1"># Create skinny table of just the nested dicts</span>
<span class="n">email_skinny</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">long_table</span><span class="p">([</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="s1">&#39;emails&#39;</span><span class="p">)</span>

<span class="nb">print</span> <span class="p">(</span><span class="n">email_skinny</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span> <span class="s1">&#39;emails_home&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@gmail.com&#39;</span><span class="p">,</span> <span class="s1">&#39;emails_work&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;5421&#39;</span><span class="p">,</span> <span class="s1">&#39;emails_home&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;emails_work&#39;</span><span class="p">:</span> <span class="s1">&#39;jane@mywork.com&#39;</span><span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>key: lst</dt>
<dd>The columns to retain in the long table (e.g. foreign keys)</dd>
<dt>column: str</dt>
<dd>The column name to make long</dd>
<dt>key_rename: dict</dt>
<dd>The new name for the foreign key to better identify it. For
example, you might want to rename <code class="docutils literal notranslate"><span class="pre">id</span></code> to <code class="docutils literal notranslate"><span class="pre">person_id</span></code>.
Ex. {‘KEY_NAME’: ‘NEW_KEY_NAME’}</dd>
<dt>retain_original: boolean</dt>
<dd>Retain the original column from the source table.</dd>
<dt>prepend:</dt>
<dd>Prepend the column name of the unpacked values. Useful for
avoiding duplicate column names</dd>
<dt>prepend_value:</dt>
<dd>Value to prepend new columns if <code class="docutils literal notranslate"><span class="pre">prepend=True</span></code>. If None, will
set to column name.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>Parsons Table</dt>
<dd>The new long table</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.cut">
<code class="descname">cut</code><span class="sig-paren">(</span><em>*columns</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.cut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a table of selection of columns</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>*columns: str</dt>
<dd>Columns in the parsons table</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd>A new parsons table containing the selected columnns</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.select_rows">
<code class="descname">select_rows</code><span class="sig-paren">(</span><em>*filters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.select_rows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.select_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Select specific rows from a Parsons table based on the passed
filters.</p>
<p>Example filters:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">([[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">],</span>
             <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">9.3</span><span class="p">],</span>
             <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">88.2</span><span class="p">],</span>
             <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">23.3</span><span class="p">],])</span>

<span class="c1"># You can structure the filter in multiple wayss</span>

<span class="c1"># Lambda Function</span>
<span class="n">tbl2</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="o">.</span><span class="n">foo</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span> <span class="ow">and</span> <span class="n">row</span><span class="o">.</span><span class="n">baz</span> <span class="o">&gt;</span> <span class="mf">88.1</span><span class="p">)</span>
<span class="n">tbl2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="n">foo</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="mf">88.1</span><span class="p">}</span>

<span class="c1"># Expression String</span>
<span class="n">tbl3</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{foo}</span><span class="s2"> == &#39;a&#39; and </span><span class="si">{baz}</span><span class="s2"> &gt; 88.1&quot;</span><span class="p">)</span>
<span class="n">tbl3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="n">foo</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="mf">88.1</span><span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd>*filters: function or str</dd>
<dt><cite>Returns:</cite></dt>
<dd>A new parsons table containing the selected rows</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.remove_null_rows">
<code class="descname">remove_null_rows</code><span class="sig-paren">(</span><em>columns</em>, <em>null_value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.remove_null_rows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.remove_null_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove rows if the values in a column are <code class="docutils literal notranslate"><span class="pre">None</span></code>. If multiple columns
are passed as list, it will remove all rows with null values in any
of the passed columns.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>column: str or list</dt>
<dd>The column or columns to analyze</dd>
<dt>null_value: int or float or str</dt>
<dd>The null value</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><code class="docutils literal notranslate"><span class="pre">None</span></code></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.stack">
<code class="descname">stack</code><span class="sig-paren">(</span><em>*tables</em>, <em>missing=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.stack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack Parsons tables on top of one another.</p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">table.concat()</span></code>, except no attempt is made to align fields from
different tables.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>tables: Parsons Table or list</dt>
<dd>A single table, or a list of tables</dd>
<dt>missing: bool</dt>
<dd>The value to use when padding missing values</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><code class="docutils literal notranslate"><span class="pre">None</span></code></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.concat">
<code class="descname">concat</code><span class="sig-paren">(</span><em>*tables</em>, <em>missing=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.concat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates one or more tables onto this one.</p>
<p>Note that the tables do not need to share exactly the same fields.
Any missing fields will be padded with None, or whatever is provided via the
<code class="docutils literal notranslate"><span class="pre">missing</span></code> keyword argument.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>tables: Parsons Table or list</dt>
<dd>A single table, or a list of tables</dd>
<dt>missing: bool</dt>
<dd>The value to use when padding missing values</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><code class="docutils literal notranslate"><span class="pre">None</span></code></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.chunk">
<code class="descname">chunk</code><span class="sig-paren">(</span><em>rows</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.chunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Divides a Parsons table into smaller tables of a specified row count. If the table
cannot be divided evenly, then the final table will only include the remainder.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>rows: int</dt>
<dd>The number of rows of each new Parsons table</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd>List of Parsons tables</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="parsons.etl.etl.ETL.get_normalized_column_name">
<em class="property">static </em><code class="descname">get_normalized_column_name</code><span class="sig-paren">(</span><em>column_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.get_normalized_column_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.get_normalized_column_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a column name with whitespace removed, non-alphanumeric characters removed, and
everything lowercased.</p>
<dl class="docutils">
<dt><cite>Returns:</cite></dt>
<dd><dl class="first last docutils">
<dt>str</dt>
<dd>Normalized column name</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.match_columns">
<code class="descname">match_columns</code><span class="sig-paren">(</span><em>desired_columns</em>, <em>fuzzy_match=True</em>, <em>if_extra_columns='remove'</em>, <em>if_missing_columns='add'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.match_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.match_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the column names and ordering in this Table to match a list of desired column
names.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>desired_columns: list</dt>
<dd>Ordered list of desired column names</dd>
<dt>fuzzy_match: bool</dt>
<dd>Whether to normalize column names when matching against the desired column names,
removing whitespace and non-alphanumeric characters, and lowercasing everything.
Eg. With this flag set, “FIRST NAME” would match “first_name”.
If the Table has two columns that normalize to the same string (eg. “FIRST NAME”
and “first_name”), the latter will be considered an extra column.</dd>
<dt>if_extra_columns: string</dt>
<dd>If the Table has columns that don’t match any desired columns, either ‘remove’
them, ‘ignore’ them, or ‘fail’ (raising an error).</dd>
<dt>if_missing_columns: string</dt>
<dd>If the Table is missing some of the desired columns, either ‘add’ them (with a
value of None), ‘ignore’ them, or ‘fail’ (raising an error).</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.reduce_rows">
<code class="descname">reduce_rows</code><span class="sig-paren">(</span><em>columns</em>, <em>reduce_func</em>, <em>headers</em>, <em>presorted=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.reduce_rows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.reduce_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Group rows by a column or columns, then reduce the groups to a single row.</p>
<p>Based on the <a class="reference external" href="https://petl.readthedocs.io/en/stable/transform.html#petl.transform.reductions.rowreduce">rowreduce petl function</a>.</p>
<p>For example, the output from the query to get a table’s definition is
returned as one component per row. The <cite>reduce_rows</cite> method can be used
to reduce all those to a single row containg the entire query.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ddl</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sql_to_get_table_ddl</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddl</span><span class="o">.</span><span class="n">table</span>

<span class="go">+--------------+--------------+----------------------------------------------------+</span>
<span class="go">| schemaname   | tablename    | ddl                                                |</span>
<span class="go">+==============+==============+====================================================+</span>
<span class="go">| &#39;db_scratch&#39; | &#39;state_fips&#39; | &#39;--DROP TABLE db_scratch.state_fips;&#39;              |</span>
<span class="go">+--------------+--------------+----------------------------------------------------+</span>
<span class="go">| &#39;db_scratch&#39; | &#39;state_fips&#39; | &#39;CREATE TABLE IF NOT EXISTS db_scratch.state_fips&#39; |</span>
<span class="go">+--------------+--------------+----------------------------------------------------+</span>
<span class="go">| &#39;db_scratch&#39; | &#39;state_fips&#39; | &#39;(&#39;                                                |</span>
<span class="go">+--------------+--------------+----------------------------------------------------+</span>
<span class="go">| &#39;db_scratch&#39; | &#39;state_fips&#39; | &#39;\tstate VARCHAR(1024)   ENCODE RAW&#39;               |</span>
<span class="go">+--------------+--------------+----------------------------------------------------+</span>
<span class="go">| &#39;db_scratch&#39; | &#39;state_fips&#39; | &#39;\t,stusab VARCHAR(1024)   ENCODE RAW&#39;             |</span>
<span class="go">+--------------+--------------+----------------------------------------------------+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">reducer_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">columns</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddl</span><span class="o">.</span><span class="n">reduce_rows</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;schemaname&#39;</span><span class="p">,</span> <span class="s1">&#39;tablename&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">reducer_fn</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">[</span><span class="s1">&#39;tablename&#39;</span><span class="p">,</span> <span class="s1">&#39;ddl&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">presorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddl</span><span class="o">.</span><span class="n">table</span>

<span class="go">+-------------------------+-----------------------------------------------------------------------+</span>
<span class="go">| tablename               | ddl                                                                   |</span>
<span class="go">+=========================+=======================================================================+</span>
<span class="go">| &#39;db_scratch.state_fips&#39; | &#39;--DROP TABLE db_scratch.state_fips;\nCREATE TABLE IF NOT EXISTS      |</span>
<span class="go">|                         | db_scratch.state_fips\n(\n\tstate VARCHAR(1024)   ENCODE RAW\n\t      |</span>
<span class="go">|                         | ,db_scratch.state_fips\n(\n\tstate VARCHAR(1024)   ENCODE RAW         |</span>
<span class="go">|                         | \n\t,stusab VARCHAR(1024)   ENCODE RAW\n\t,state_name                 |</span>
<span class="go">|                         | VARCHAR(1024)   ENCODE RAW\n\t,statens VARCHAR(1024)   ENCODE         |</span>
<span class="go">|                         | RAW\n)\nDISTSTYLE EVEN\n;&#39;                                            |</span>
<span class="go">+-------------------------+-----------------------------------------------------------------------+</span>
</pre></div>
</div>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>columns: list</dt>
<dd>The column(s) by which to group the rows.</dd>
<dt>reduce_func: fun</dt>
<dd>The function by which to reduce the rows. Should take the 2
arguments, the columns list and the rows list and return a list.
<cite>reducer(columns: list, rows: list) -&gt; list;</cite></dd>
<dt>headers: list</dt>
<dd>The list of headers for modified table. The length of <cite>headers</cite>
should match the length of the list returned by the reduce
function.</dd>
<dt>presorted: bool</dt>
<dd>If false, the row will be sorted.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>columns=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the rows a table.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>sort_columns: list or str</dt>
<dd>Sort by a single column or a list of column. If <code class="docutils literal notranslate"><span class="pre">None</span></code> then
will sort columns from left to right.</dd>
<dt>reverse: boolean</dt>
<dd>Sort rows in reverse order.</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="parsons.etl.etl.ETL.set_header">
<code class="descname">set_header</code><span class="sig-paren">(</span><em>new_header</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parsons/etl/etl.html#ETL.set_header"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsons.etl.etl.ETL.set_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the header row of the table.</p>
<dl class="docutils">
<dt><cite>Args:</cite></dt>
<dd><dl class="first last docutils">
<dt>new_header: list</dt>
<dd>List of new header column names</dd>
</dl>
</dd>
<dt><cite>Returns:</cite></dt>
<dd><cite>Parsons Table</cite> and also updates self</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="notifications.html" class="btn btn-neutral float-right" title="Notifications" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dbsync.html" class="btn btn-neutral" title="Database Sync" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, The Movement Cooperative

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>